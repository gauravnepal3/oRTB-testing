# Fan-out
fanout.count=10
fanout.totalTimeoutMs=300

# Kafka (producer)
kafka.bootstrap=${KAFKA_BOOTSTRAP:kafka:29092}
kafka.acks=0
kafka.lingerMs=${KAFKA_LINGERMS:5}
kafka.batchBytes=${KAFKA_BATCHBYTES:262144}
kafka.compression=${KAFKA_COMPRESSION:lz4}

# Kafka (consumer) ? keep batches small to avoid heap spikes
kafka.group=rtb-ch-sink
kafka.topic.requests=rtb_requests
kafka.topic.responses=rtb_responses

# ClickHouse
clickhouse.url=${CLICKHOUSE_URL:jdbc:ch://clickhouse:8123/default?async_insert=1&wait_for_async_insert=0}
clickhouse.user=${CLICKHOUSE_USER:default}
clickhouse.password=${CLICKHOUSE_PASSWORD:}
clickhouse.sinkBatch=500

# Reactive server safeguard
spring.codec.max-in-memory-size=64KB

# Expose actuator metrics on a separate port (recommended)
management.server.port=8081
management.server.address=0.0.0.0
management.endpoints.web.exposure.include=prometheus,health,info,metrics
management.endpoint.prometheus.enabled=true

# (Optional) global app tag so all metrics carry app="rtb-app"
management.metrics.tags.app=rtb-app

# Make a histogram for our custom timer so Prometheus gets _bucket metrics
management.metrics.distribution.percentiles-histogram.rtb.outgoing=true
# (Optional) fixed buckets (ms) for nicer latency graphs
management.metrics.distribution.slo.rtb.outgoing=10ms,25ms,50ms,75ms,100ms,150ms,200ms,250ms,300ms,400ms,500ms